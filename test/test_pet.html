<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Pet Test</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.13.0/gsap.min.js" integrity="sha512-NcZdtrT77bJr4STcmsGAESr06BYGE8woZdSdEgqnpyqac7sugNO+Tr4bGwGF3MsnEkGKhU2KL2xh6Ec+BqsaHA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        .main-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #box {
            position: absolute;
            background-position: 0px 0px;
            cursor: pointer;
        }

        #pixel-pet {
            position: absolute;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            cursor: pointer;
            transition: transform 0.1s ease;
        }

        #pixel-pet:hover {
            transform: scale(1.2);
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            font-family: 'Montserrat', sans-serif;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .controls h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .controls button {
            margin: 5px;
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            background: #667eea;
            color: white;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
        }

        .controls button:hover {
            background: #5a6fd8;
        }

        .controls .toggle-movement {
            background: #28a745 !important;
        }

        .controls .toggle-movement.active {
            background: #dc3545 !important;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div id="box"></div>

        <div class="controls">
            <h3>Pet Controls</h3>

            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Choose Pet:</label>
                <select id="petSelector" onchange="changePet(this.value)" style="padding: 8px; border-radius: 5px; border: 1px solid #ccc;">
                    <option value="cat" selected>üê± Cat (Sprite)</option>
                    <option value="pixel">üéÆ Pixel Pet</option>
                    <option value="gif">üé¨ GIF Pet (FSM)</option>
                </select>
            </div>

            <button onclick="feedPet()">Feed Pet (üçñ)</button>
            <button onclick="petPet()">Pet Pet (üêæ)</button>
            <button onclick="triggerFollow()">Follow Event</button>
            <button onclick="triggerRaid()">Raid Event</button>
            <button onclick="toggleMovement()" class="toggle-movement active" id="movementBtn">Stop Movement</button>
            <br>
            <small>Or use keyboard: F=Follow, E=Eat, P=Pet, R=Raid, M=Toggle Movement</small>
        </div>
    </div>

    <script>
        let box = document.getElementById('box')
        let fieldData, size, pozx, pozy, sprite, animation_queue, box_width, box_height, backgroundImageWidth, backgroundImageHeight, animationRepeat, animationImportant, timeBetweenIdle, hungerLevel, sleepLevel, isHunger, isSleep, needyTime, needyTimeTotal, currentAnimation, followEventDuration, cheerEventDuration, raidEventDuration, subEventDuration, specialRedemptionName, specialRedemptionDuration, eatingDuration, pettingDuration
        let tl, reverb, movementInterval, isMoving, currentPetType = 'cat', pixelPetElement, pixelFrameIndex = 0, gifPetElement
        animation_queue = []
        isMoving = false

        // Pixel Art Sprite Data (8x8 pixel character)
        const PIXEL_SPRITE_DATA = {
            idle: [
                "00011000",
                "00111100",
                "01111110",
                "11111111",
                "11111111",
                "01111110",
                "00111100",
                "00011000"
            ],
            walk1: [
                "00011000",
                "00111100",
                "01111110",
                "11111111",
                "11111111",
                "01111110",
                "00111000",
                "00010000"
            ],
            walk2: [
                "00011000",
                "00111100",
                "01111110",
                "11111111",
                "11111111",
                "01111110",
                "00011100",
                "00001100"
            ],
            hungry: [
                "00011000",
                "00100100",
                "01000010",
                "10000001",
                "10000001",
                "01000010",
                "00100100",
                "00011000"
            ],
            sleep: [
                "00000000",
                "00011000",
                "00111100",
                "01111110",
                "11111111",
                "01111110",
                "00111100",
                "00011000"
            ],
            eat: [
                "00011000",
                "00111100",
                "01111110",
                "11111111",
                "11111111",
                "01111110",
                "00111100",
                "00011000"
            ],
            happy: [
                "00011000",
                "00111100",
                "01111110",
                "11111111",
                "11111111",
                "01111110",
                "00111100",
                "00011000"
            ]
        };

        // Mock fieldData for web usage
        const mockFieldData = {
            pozy: 300,
            pozx: 400,
            size: 150, // smaller size for web
            model: "cat",
            "time-between-random-idle": 6,
            "is-hunger": true,
            "is-sleepy": true,
            "needy-time": 120,
            "follow-event-duration": 6,
            "sub-event-duration": 6,
            "cheer-event-duration": 6,
            "raid-event-duration": 20,
            "special-rademption-name": "PUT THE CAT IN A BOX",
            "special-rademption-duration": 60,
            "eating-duration": 4,
            "petting-duration": 4,
            cat: {
                sprite: "https://cdn.streamelements.com/uploads/01k54bwk3ejrjdyy6eqz0wd7e2.png",
                sprite_height: 32,
                sprite_width: 32,
                image_height: 800,
                image_width: 512,
                idle1_position: 1,
                idle1_frames: 10,
                idle1_duration: 1,
                idle2_position: 2,
                idle2_frames: 10,
                idle2_duration: 1,
                idle3_position: 20,
                idle3_frames: 11,
                idle3_duration: 1.5,
                yawn_position: 5,
                yawn_frames: 8,
                yawn_duration: 1.5,
                sleepy1_position: 7,
                sleepy1_frames: 12,
                sleepy1_duration: 1.5,
                sleepy2_position: 3,
                sleepy2_frames: 4,
                sleepy2_duration: 1.5,
                special_position: 12,
                special_frames: 4,
                special_duration: 1,
                hungry1_position: 15,
                hungry1_frames: 6,
                hungry1_duration: 1,
                hungry2_position: 17,
                hungry2_frames: 9,
                hungry2_duration: 1.5,
                hungry3_position: 9,
                hungry3_frames: 4,
                hungry3_duration: 1,
                hungry4_position: 21,
                hungry4_frames: 5,
                hungry4_duration: 2,
                eating_position: 14,
                eating_frames: 15,
                eating_duration: 2,
                raid_position: 4,
                raid_frames: 4,
                raid_duration: 0.5,
                follow_position: 6,
                follow_frames: 12,
                follow_duration: 1,
                refusing_position: 16,
                refusing_frames: 13,
                refusing_duration: 2,
                petting_position: 23,
                petting_frames: 5,
                petting_duration: 0.2
            }
        };

        function initWebPet() {
            fieldData = mockFieldData;

            size = fieldData.size;
            pozx = fieldData.pozx;
            pozy = fieldData.pozy;

            timeBetweenIdle = fieldData["time-between-random-idle"];
            needyTimeTotal = fieldData["needy-time"];
            isSleep = fieldData["is-sleepy"];
            isHunger = fieldData["is-hunger"];

            followEventDuration = fieldData["follow-event-duration"];
            cheerEventDuration = fieldData["cheer-event-duration"];
            raidEventDuration = fieldData["raid-event-duration"];
            subEventDuration = fieldData["sub-event-duration"];
            specialRedemptionName = fieldData["special-rademption-name"];
            specialRedemptionDuration = fieldData["special-rademption-duration"];
            eatingDuration = fieldData["eating-duration"];
            pettingDuration = fieldData["petting-duration"];

            model_name = fieldData.model;
            model = fieldData[model_name];

            sprite = model.sprite;
            backgroundImageWidth = model.image_width;
            backgroundImageHeight = model.image_height;

            box_width = model.sprite_width * size / 100;
            box_height = model.sprite_height * size / 100;

            box.style.left = pozx + "px";
            box.style.top = pozy + "px";
            box.style.width = box_width + "px";
            box.style.height = box_height + "px";
            box.style.backgroundImage = `url('${sprite}')`;
            box.style.backgroundSize =
                backgroundImageWidth * size / 100 + "px " +
                backgroundImageHeight * size / 100 + "px";

            startAnimating();
        }

        function startAnimating(){
            tl = gsap.timeline()

            hungerLevel = 0
            sleepLevel = 0
            animationImportant = false;
            currentAnimation = "idle1";
            needyTime = needyTimeTotal
            animationRepeat = timeBetweenIdle

            animate(currentAnimation)

            // Start random movement every 10-20 seconds
            startRandomMovement()
        }

        function startRandomMovement() {
            // Clear existing interval if any
            if (movementInterval) {
                clearInterval(movementInterval);
            }

            // Move pet to random position every 10-20 seconds (only when idle)
            movementInterval = setInterval(() => {
                if (!isMoving && !animationImportant && hungerLevel === 0 && sleepLevel === 0) {
                    moveToRandomPosition();
                }
            }, Math.random() * 10000 + 10000); // 10-20 seconds
        }

        function moveToRandomPosition() {
            if (isMoving || animationImportant || hungerLevel > 0 || sleepLevel > 0) return;

            isMoving = true;

            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Calculate random position (keeping pet within bounds)
            const margin = 50; // Keep pet away from edges
            let petWidth, petHeight, targetElement;

            if (currentPetType === 'cat') {
                petWidth = box_width;
                petHeight = box_height;
                targetElement = box;
            } else if (currentPetType === 'pixel') {
                petWidth = 64;
                petHeight = 64;
                targetElement = pixelPetElement;
            } else if (currentPetType === 'gif') {
                petWidth = 128;
                petHeight = 128;
                targetElement = gifPetElement;
            }

            const randomX = Math.random() * (viewportWidth - petWidth - margin * 2) + margin;
            const randomY = Math.random() * (viewportHeight - petHeight - margin * 2) + margin;

            console.log(`Moving ${currentPetType} pet to: ${randomX.toFixed(0)}, ${randomY.toFixed(0)}`);

            // Animate movement using GSAP
            gsap.to(targetElement, {
                x: randomX - pozx,
                y: randomY - pozy,
                duration: 3 + Math.random() * 2, // 3-5 seconds
                ease: "power2.inOut",
                onComplete: () => {
                    // Update actual position
                    pozx = randomX;
                    pozy = randomY;
                    targetElement.style.left = pozx + "px";
                    targetElement.style.top = pozy + "px";

                    // Reset transform
                    gsap.set(targetElement, { x: 0, y: 0 });

                    isMoving = false;
                    console.log(`${currentPetType} pet movement completed`);
                }
            });
        }

        function animate(animation){
            var duration = model[ animation + "_duration"]
            animationRepeat = animationRepeat - duration
            needyTime = needyTime - duration
            var steps = model[ animation + "_frames"] - 1
            var topPosition = -((model[ animation + "_position"] - 1) * box_height);
            var final_position = -((steps) * box_width)
            if (reverb){
                box.style.backgroundPosition = final_position + "px " + topPosition + "px"
                tl.to("#box",{ backgroundPosition: "0px " + topPosition + "px", ease: "steps(" + steps + ")", duration: duration})
                animationRepeat = animationRepeat - duration
                needyTime = needyTime - duration
            } else{
                box.style.backgroundPosition = "0px " + topPosition + "px"
            }
            tl.to("#box",{ backgroundPosition: final_position + "px " + topPosition + "px", ease: "steps(" + steps + ")", duration: duration, onComplete: tlComplete})
        }

        function handleImportantAnimation(){
            animationImportant = true
            var current_event = animation_queue.shift()
            switch (current_event){
                case "follow":
                    if(followEventDuration!=0){
                        currentAnimation = "follow"
                        animationRepeat = followEventDuration
                        sleepLevel = 0
                        needyTime = needyTimeTotal
                    }else{
                        handleNotImportantAnimation()
                    }
                break;
                case "sub":
                    if(subEventDuration!=0){
                        currentAnimation = "follow"
                        animationRepeat = subEventDuration
                        sleepLevel = 0
                        needyTime = needyTimeTotal
                    }else{
                        handleNotImportantAnimation()
                    }
                break;
                case "cheer":
                    if(cheerEventDuration!=0){
                        currentAnimation = "follow"
                        animationRepeat = cheerEventDuration
                        sleepLevel = 0
                        needyTime = needyTimeTotal
                    }else{
                        handleNotImportantAnimation()
                    }
                break;
                case "raid":
                    if(raidEventDuration!=0){
                        currentAnimation = "raid"
                        animationRepeat = raidEventDuration
                        sleepLevel = 0
                        needyTime = needyTimeTotal
                    }else{
                        handleNotImportantAnimation()
                    }
                break;
                case "special":
                    if(specialRedemptionDuration!=0){
                        if(hungerLevel <= 1){
                            currentAnimation = "special"
                            animationRepeat = specialRedemptionDuration
                            sleepLevel = 0
                            needyTime = needyTimeTotal
                        }else{
                            currentAnimation = "refusing"
                            animationRepeat = 6
                            needyTime = needyTimeTotal
                        }
                    }else{
                        handleNotImportantAnimation()
                    }
                break;
                case "eat":
                    if(eatingDuration!=0){
                        currentAnimation = "eating"
                        animationRepeat = eatingDuration
                        sleepLevel = 0
                        hungerLevel = 0
                        needyTime = needyTimeTotal
                    }else{
                        handleNotImportantAnimation()
                    }
                break;
                case "pet":
                    if(pettingDuration!=0){
                        if(hungerLevel <= 1){
                            currentAnimation = "petting"
                            animationRepeat = pettingDuration
                            sleepLevel = 0
                            needyTime = needyTimeTotal
                        }else{
                            currentAnimation = "refusing"
                            animationRepeat = 6
                            needyTime = needyTimeTotal
                        }
                    }else{
                        handleNotImportantAnimation()
                    }
                break;
                default:
            }
        }

        function handleNotImportantAnimation(){
            animationImportant = false
            if (needyTime <= 0 && (isSleep || isHunger)){
                if(hungerLevel == 0 && sleepLevel == 0){
                    if (isSleep && isHunger){
                        var rand = Math.floor(Math.random() * 3)
                        if (rand == 1){
                            hungerLevel = 1
                        }else{
                            sleepLevel = 1
                        }
                    }else{
                        if (isHunger){
                            hungerLevel = 1
                        }
                        if (isSleep){
                            sleepLevel = 1
                        }
                    }
                }else{
                    if(hungerLevel > 0){
                        if(hungerLevel < 4){
                            hungerLevel = hungerLevel + 1
                        }
                    }
                    if(sleepLevel > 0){
                        if(sleepLevel < 3){
                            sleepLevel = sleepLevel + 1
                        }else{
                            sleepLevel = 0
                            currentAnimation = "idle1"
                            animationRepeat = timeBetweenIdle;
                        }
                    }
                }
                needyTime = needyTimeTotal
            }
            if (hungerLevel != 0){
                currentAnimation = "hungry" + hungerLevel
            }
            if (sleepLevel != 0){
                if (sleepLevel == 1){
                    if(animationRepeat <= 0){
                        currentAnimation = "yawn"
                        animationRepeat = 10
                    }else{
                        currentAnimation = "idle1"
                    }
                }else{
                    currentAnimation = "sleepy" + (sleepLevel-1)
                }
            }
            if (animationRepeat <= 0 && needyTime >= 0 && hungerLevel == 0 && sleepLevel == 0){
                currentAnimation = "idle" + (Math.floor(Math.random() * 3)+1);
                if(currentAnimation == 'idle3'){
                    animationRepeat = timeBetweenIdle/2;
                }else{
                    animationRepeat = timeBetweenIdle;
                }
            }
        }

        function tlComplete(){
            if (animationRepeat <= 0 || !animationImportant){
                if(animation_queue.length > 0){
                    handleImportantAnimation()
                }else{
                    handleNotImportantAnimation()
                }
            }
            if (currentAnimation == "yawn"){
                reverb = true
            }else{
                reverb = false
            }
            animate(currentAnimation)
        }

        // Pixel art functions
        function createPixelSprite(data, color = '#00ff00') {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const pixelSize = 8;
            canvas.width = pixelSize;
            canvas.height = pixelSize;

            ctx.fillStyle = color;
            for (let y = 0; y < pixelSize; y++) {
                for (let x = 0; x < pixelSize; x++) {
                    if (data[y][x] === '1') {
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }

            return canvas.toDataURL();
        }

        function animatePixelFrame() {
            if (currentPetType !== 'pixel') return;

            const frames = ['idle', 'walk1', 'idle', 'walk2'];
            const currentFrame = frames[pixelFrameIndex % frames.length];
            const spriteData = PIXEL_SPRITE_DATA[currentFrame] || PIXEL_SPRITE_DATA.idle;

            pixelPetElement.style.backgroundImage = `url('${createPixelSprite(spriteData)}')`;
            pixelPetElement.style.backgroundSize = '64px 64px';

            pixelFrameIndex++;
            gsap.delayedCall(0.2, animatePixelFrame);
        }

        function changePet(petType) {
            currentPetType = petType;

            if (petType === 'cat') {
                // Show cat pet
                box.style.display = 'block';
                if (pixelPetElement) pixelPetElement.style.display = 'none';

                // Reinitialize cat pet
                fieldData = mockFieldData;
                size = fieldData.size;
                pozx = fieldData.pozx;
                pozy = fieldData.pozy;
                model_name = fieldData.model;
                model = fieldData[model_name];
                sprite = model.sprite;
                backgroundImageWidth = model.image_width;
                backgroundImageHeight = model.image_height;
                box_width = model.sprite_width * size / 100;
                box_height = model.sprite_height * size / 100;

                box.style.left = pozx + "px";
                box.style.top = pozy + "px";
                box.style.width = box_width + "px";
                box.style.height = box_height + "px";
                box.style.backgroundImage = `url('${sprite}')`;
                box.style.backgroundSize = backgroundImageWidth * size / 100 + "px " + backgroundImageHeight * size / 100 + "px";

                startAnimating();

            } else if (petType === 'pixel') {
                // Hide cat pet
                box.style.display = 'none';

                // Create pixel pet if not exists
                if (!pixelPetElement) {
                    pixelPetElement = document.createElement('div');
                    pixelPetElement.id = 'pixel-pet';
                    pixelPetElement.style.position = 'absolute';
                    pixelPetElement.style.width = '12.8px';  // 64px * 0.2
                    pixelPetElement.style.height = '12.8px'; // 64px * 0.2
                    pixelPetElement.style.imageRendering = 'pixelated';
                    pixelPetElement.style.left = pozx + 'px';
                    pixelPetElement.style.top = pozy + 'px';
                    pixelPetElement.style.cursor = 'pointer';
                    document.querySelector('.main-container').appendChild(pixelPetElement);

                    // Add event listeners for pixel pet
                    pixelPetElement.addEventListener("click", handlePetClick);
                    pixelPetElement.addEventListener("mouseenter", handlePetHover);
                } else {
                    pixelPetElement.style.display = 'block';
                }

                // Start pixel animation
                animatePixelFrame();
                startRandomMovement();

            } else if (petType === 'gif') {
                // Hide cat and pixel pets
                box.style.display = 'none';
                if (pixelPetElement) pixelPetElement.style.display = 'none';

                // Create GIF pet if not exists
                if (!gifPetElement) {
                    gifPetElement = document.createElement('img');
                    gifPetElement.id = 'gif-pet';
                    gifPetElement.style.position = 'absolute';
                    gifPetElement.style.width = '25.6px';  // 128px * 0.2
                    gifPetElement.style.height = '25.6px'; // 128px * 0.2
                    gifPetElement.style.left = pozx + 'px';
                    gifPetElement.style.top = pozy + 'px';
                    gifPetElement.style.cursor = 'pointer';
                    gifPetElement.style.imageRendering = 'pixelated';
                    document.querySelector('.main-container').appendChild(gifPetElement);

                    // Add event listeners for GIF pet
                    gifPetElement.addEventListener("click", handlePetClick);
                    gifPetElement.addEventListener("mouseenter", handlePetHover);
                } else {
                    gifPetElement.style.display = 'block';
                }

                // Set initial GIF state
                gifPetElement.src = 'black_idle_8fps.gif';
                startRandomMovement();
            }

            console.log(`Switched to ${petType} pet`);
        }

        // Initialize when DOM is ready
        window.addEventListener("DOMContentLoaded", () => {
            initWebPet();
            setupEventListeners();
        });

        function setupEventListeners() {
            // Web-specific event handlers
            window.feedPet = function() {
                animation_queue.push("eat");
            };

            window.petPet = function() {
                animation_queue.push("pet");
            };

            window.triggerFollow = function() {
                animation_queue.push("follow");
            };

            window.triggerRaid = function() {
                animation_queue.push("raid");
            };

            window.toggleMovement = function() {
                const btn = document.getElementById('movementBtn');
                if (movementInterval) {
                    // Stop movement
                    clearInterval(movementInterval);
                    movementInterval = null;
                    btn.textContent = 'Start Movement';
                    btn.classList.remove('active');
                    console.log('Pet movement stopped');
                } else {
                    // Start movement
                    startRandomMovement();
                    btn.textContent = 'Stop Movement';
                    btn.classList.add('active');
                    console.log('Pet movement started');
                }
            };

            // Click to feed (works with both pet types)
            function handlePetClick(e) {
                e.stopPropagation(); // Prevent event bubbling
                animation_queue.push("eat");
                console.log(`${currentPetType} pet fed! Queue:`, animation_queue);
            }

            function handlePetHover() {
                animation_queue.push("pet");
                console.log(`${currentPetType} pet petted! Queue:`, animation_queue);
            }

            // Add event listeners to both pets
            box.addEventListener("click", handlePetClick);
            box.addEventListener("mouseenter", handlePetHover);

            // Pixel pet events will be added when pixel pet is created

            // Click anywhere else to feed
            document.addEventListener("click", (e) => {
                // Only if not clicking on the pet or controls
                if (!box.contains(e.target) && !e.target.closest('.controls')) {
                    animation_queue.push("eat");
                    console.log("Background clicked - Pet fed! Queue:", animation_queue);
                }
            });

            // Keyboard shortcuts
            document.addEventListener("keydown", e => {
                if (e.key === "f" || e.key === "F") {
                    animation_queue.push("follow");
                    console.log("Follow triggered! Queue:", animation_queue);
                }
                if (e.key === "e" || e.key === "E") {
                    animation_queue.push("eat");
                    console.log("Eat triggered! Queue:", animation_queue);
                }
                if (e.key === "p" || e.key === "P") {
                    animation_queue.push("pet");
                    console.log("Pet triggered! Queue:", animation_queue);
                }
                if (e.key === "r" || e.key === "R") {
                    animation_queue.push("raid");
                    console.log("Raid triggered! Queue:", animation_queue);
                }
                if (e.key === "m" || e.key === "M") {
                    toggleMovement();
                }
            });
        }
    </script>
</body>
</html>